#+TITLE: Assignment08
#+SETUPFILE: ~/Desktop/Metodos_Computacionales_taller/Tareas/Entrega_tareas_2021/1001577699/org-html-themes/org/theme-readtheorg-local.setup

#+begin_src ipython :session asession :results raw drawer
import numpy as np
import scipy as sc
import sympy as sp
from scipy import optimize
#+end_src

#+RESULTS:
:results:
# Out[1]:
:end:

Class for finding approximate integral values and bounding errors in numerical integration.
#+begin_src ipython :session asession :results raw drawer
def closed_set_max(func, variable, lower_bound, upper_bound) :
    ''' Find the maximum of a smooth funtion on an open interval '''
    d_func = sp.diff(func, variable, 1)
    critical = sp.solveset(d_func, variable,
                           domain=sp.Interval(lower_bound, upper_bound))
    maximum = sp.Max(func.subs(variable, lower_bound),
                     func.subs(variable, upper_bound),
                     ,*[func.subs(variable, i) for i in critical])
    return float(maximum)

class Function :
    ''' Properties of a $C^{\infty}$ function. Class for integration. '''
    def __init__(self, expression, variable, a=0, b=1) :
        ''' the mathematical expression must be a sympy object '''
        self.numerical = sp.lambdify(variable, expression, 'numpy')
        self.symbol = variable
        self.symbolic = expression
        self.a, self.b = a, b

    def simpson_partition(self, epsilon=0.001) :
        # compute the fourth derivative with sympy
        fourth_deriv = sp.diff(self.symbolic, self.symbol, 4)

        # find an absolute maximum for the fourth derivative on the given domain
        maximum = closed_set_max(fourth_deriv, self.symbol, self.a, self.b)

        # compute the number of intervals
        return np.ceil( ((maximum*(self.b - self.a)**5)/(epsilon*180*2**4))**0.25 )

    def simpson(self, epsilon=0.001) :
        N = self.simpson_partition(epsilon)
        n_nodos = int( np.ceil(2*N + 1) ) # (N+1 extremos de subintervalos) + (N puntos medios)
        x = np.linspace(self.a, self.b, n_nodos)

        x_impar = x[1: :2] # Nodos con coordenada impar (ptos medios)
        x_par = x[2:n_nodos-1:2] # Nodos con coordenada par (salvo e

        h = (self.b - self.a)/(2*N) # Distancia entre dos nodos de integraci√≥n
        cuad = h/3*(self.numerical(self.a) + 2*sum(self.numerical(x_par)) + 4*sum(self.numerical(x_impar)) + self.numerical(self.b))
        return f'Value = {cuad} +/- {epsilon}'

x = sp.Symbol('x')
f = Function(sp.log(1 + x**2), x)

f.simpson(epsilon=1e-5)
#+end_src

#+RESULTS:
:results:
# Out[3]:
: 'Value = 0.2639421665115566 +/- 1e-05'
:end:

#+begin_src ipython :session asession :results raw drawer
g = Function(x**5, x, a=1, b=12)
g.simpson(epsilon=1e-5)
#+end_src

#+RESULTS:
:results:
# Out[4]:
: 'Value = 497663.8333387183 +/- 1e-05'
:end:
