#+TITLE: Coupled harmonic oscillators
#+SETUPFILE: ~/Desktop/Metodos_Computacionales_taller/Tareas/Entrega_tareas_2021/1001577699/org-html-themes/org/theme-readtheorg-local.setup

#+begin_src ipython :session asession :results raw drawer :exports both
%config InlineBackend.figure_format = 'svg'

import numpy as np
import matplotlib.pyplot as plt
import scipy.integrate as integrate
import numpy.linalg as la
#+end_src

#+RESULTS:
:results:
# Out[510]:
:end:

* $N$ coupled harmonic oscillators: Normal modes
Many physical systems can be thought of as a collection of oscillators
influencing each other in potentially quite complex ways. Such behaviours can
certainly arise, even in one of the simplest such systems, namely, two pendulums
of the same mass $m$ and length $l$, connected by a spring with sping constant
$\kappa$, whose unstreched length is the distance between the two pendulums when
they are in vertical (equilibrium) position.
[[file:./media/coupled_drawing.svg]]

Let us momentarily work with the small-angle approximation, so as to make the
general discussion simpler. Letting $K := \kappa/m$ and $\omega_0 = \sqrt{g/l}$,
the displacements of the two pendulums from their vertical positions can be
written as the pair of equations
\begin{gather*}
{x_1}'' + {\omega_0}^2 x_1 = -K(x_1 - x_2), \\
{x_2}'' + {\omega_0}^2 x_2 = -K(x_2 - x_1).
\end{gather*}

These may be solved, provided some initial conditions, with the help of various
mathematical tricks. However, it is usual to investigate the most "obvious"
solutions thereof, where the pendulums either move in sync ($x_1 = x_2$) or in
anti-sync ($x_1 = -x_2$).

Synchronised motion leads to identical equations
\[ {x_i}'' + {\omega_0}^2 x_i = 0, \]
so that both pendulums have a frequency $\omega_0$ with
\[ x_1(t) = x_2(t) = a \cos \omega_0 t + b \sin \omega_0 t, \]
for some real numbers $a, b$.

Anti-sync motion, on the other hand, leads to the equations
\[ {x_i}'' + {\omega_0}^2 x_i = -2 K x_i, \]
which is to say that both pendulums have a frequency
\[ {\omega_0}^+ := \sqrt{{\omega_0}^2 + 2K}; \]
ultimately giving
\begin{gather*}
x_1(t) = c \cos {\omega_0}^+ t + d \sin {\omega_0}^+ t, \\
x_2(t) = -c \cos {\omega_0}^+ t - d \sin {\omega_0}^+ t.
\end{gather*}

Such solutions, known as the /normal modes/ of the system, are particularly
interesting because the pendulums have the /same period/. As a matter of fact,
combinations of the two normal modes,
\begin{gather*}
x_1(t) = a \cos \omega_0 t + b \sin \omega_0 t + c \cos {\omega_0}^+ t + d \sin {\omega_0}^+ t, \\
x_2(t) = a \cos \omega_0 t + b \sin \omega_0 t - c \cos {\omega_0}^+ t - d \sin {\omega_0}^+ t,
\end{gather*}
with four arbitrary constants $a,b,c,d$, will give us a solution with any
desired initial conditions $x_i(0), {x_i}'(0)$.

Generalisations of these considerations to $N$ harmonic oscillators, all
interacting in a linear way, is easy. If we have $n$ possibly different masses,
$m_i$ and lengths $l_i$, by setting
\[ K_i = \frac{\kappa}{m_i} \quad {\omega_i}^2 = \frac{g}{l_i}, \]
we should get $N$ equations of the form
\begin{equation}
{x_i}''(t) + {\omega_i}^2 x_i(t) = \sum_{l=1}^N a_{il}x_l, \quad i = 1,\ldots,N;
\end{equation}
where each $a_{il}$ is some real number depending on some $K_i$, and $a_{il} =
a_{li}$ because of Newton's third law.

In this case, for a normal mode, we get complex solutions
\[ x_i(t) = c_i e^{i\lambda t}, \quad i = 1,\ldots,N; \]
whose real part represnt the motion of the $N$ oscillators. Hence we must have:
\[ -\lambda^2 c_i e^{i\lambda t} + {\omega_i}^2 c_i e^{i\lambda t}  = \sum_{l=1}^N a_{il} c_l e^{i\lambda t}, \quad i = 1,\ldots,N; \]
which can be rewritten as
\[ -\lambda^2 c_i = \sum_{l=1}^N a_{il} c_l - c_i {\omega_i}^2, \quad i = 1,\ldots,N. \]
In matrix form, this may be seen as
\[ \lambda^2 \begin{pmatrix} c_1 \\ \vdots \\ c_N \end{pmatrix}
= \left[ \begin{pmatrix} {\omega_1}^2 &  & 0 \\  & \ddots &  \\ 0 &  & {\omega_N}^2 \end{pmatrix} - \begin{pmatrix} a_{11} & \cdots & a_{1N} \\ \vdots & \ddots & \vdots \\ a_{N1} & \cdots & a_{NN} \end{pmatrix} \right] \begin{pmatrix} c_1 \\ \vdots \\ c_N \end{pmatrix}. \]
Therefore, it is clear that $\lambda^2$ is an eigenvalue of the matrix in
brackets, while each $c_i$ is a component of the corresponding eigenvector. Our
problem (that of finding the normal modes) amounts to solving an eigenvalue
problem depending on the parameters of the system. Of course, the matrix in
brackets turns out to be symmetric, so the spectral theorem tells us that it is
diagonalisable, and that there exists a basis of eigenvectors with real
eigenvalues.

Notice that the aforementioned discussion was given in terms of arbitrary
parameters $a_{ij}$, yet we wish to address the particular case of $n$
coupled pendulums. Luckily, we have the apparatus of Newton's second law, which
will help us find the parameters that should be used in our equation.

In our appriximation, we have
\begin{align*}
F_{i,\text{springs}} &= \kappa(x_i - x_{i-1}) - \kappa(x_{i+1} - x_i), \\
&= \kappa(-x_{i-1} + 2x_i - x_{i+1}).
\end{align*}
Thus equation (1) turns into
\begin{align*}
{x_i}''(t) + {\omega_i}^2 x_i(t) &= \frac{\kappa}{m_i} (-x_{i-1} + 2x_i -x_{i+1}), \quad i = 1,\ldots,N, \\
&:= K_i (-x_{i-1} + 2x_i -x_{i+1}), \quad i = 1,\ldots,N;
\end{align*}
and so for a normal mode we have:
\[ \lambda^2 \begin{pmatrix} c_1 \\ \vdots \\ c_N \end{pmatrix}
= \left[ \begin{pmatrix} {\omega_1}^2 &  & 0 \\  & \ddots &  \\ 0 &  & {\omega_N}^2 \end{pmatrix} +
\begin{pmatrix} 2K_1 & -K_1 & 0 & 0 & \cdots \\ -K_2 & 2K_2 & -K_2 & 0 & \cdots \\ 0 & -K_3 & 2K_3 & -K_3 & \cdots \\ \vdots & \vdots & \vdots & \vdots & \end{pmatrix} \right]
\begin{pmatrix} c_1 \\ \vdots \\ c_N \end{pmatrix}. \]
Hence we just need to solve the aforementioned eigenvalue problem with this matrix in particular.
#+begin_src ipython :session asession :results raw drawer :exports both
g = 9.8

class CoupledPendulums:

    def __init__(self, elastic_constant, masses, lengths):
        if len(masses) != len(lengths):
            raise ValueError
        else:
            self.elastic_constant = elastic_constant
            self.masses = np.asarray(masses)
            self.lengths = np.asarray(lengths)
            self.N = len(masses)

    def normal_modes_matrix(self):
        K = self.elastic_constant/self.masses
        omega_squared = g/self.lengths

        matrix = np.zeros((self.N, self.N), dtype=float)
        # there must be a better way to handle the exceptions here
        for i in range(self.N):
            if i-1 < 0:
                matrix[i,i] = K[i]
                matrix[i,i+1] = -K[i]
            else:
                try:
                    matrix[i,i] = 2*K[i]
                    matrix[i,i-1] = -K[i]
                    matrix[i,i+1] = -K[i]
                except IndexError:
                    matrix[i,i] = K[i]
                    matrix[i,i-1] = -K[i]

        return np.diag(omega_squared) + matrix

    def normal_modes(self, time_domain=np.linspace(0,100,1000)):
        M = self.normal_modes_matrix()
        frequencies_squared, amplitudes_matrix = np.linalg.eig(M)
        frequencies = np.sqrt(frequencies_squared)
        amplitudes = amplitudes_matrix.T

        # A list of N matrices of dimension N x len(time)
        x_coords = np.zeros((self.N, self.N, len(time_domain)))
        for i in range(self.N):
            for j in range(self.N):
                 complex_exponential = amplitudes[i,j] * np.exp(complex(0,1)*frequencies[i]*time_domain)
                 x_coords[i,j] = complex_exponential.real
        return x_coords
#+end_src

#+RESULTS:
:results:
# Out[511]:
:end:

#+begin_src ipython :session asession :results raw drawer :exports both
time = np.linspace(0,30,500)
system = CoupledPendulums(1, [5]*5, [1]*5)
x_coords = system.normal_modes(time_domain=time)
# M = system.normal_modes_matrix()
# a, b = np.linalg.eig(M)
# b.T
#+end_src

#+RESULTS:
:results:
# Out[512]:
:end:

For instance, we have the following normal mode:
#+begin_src ipython :session asession :results raw drawer :exports both
plt.plot(time, x_coords[0,0])
plt.plot(time, x_coords[0,1])
plt.plot(time, x_coords[0,2])
plt.plot(time, x_coords[0,3])
plt.plot(time, x_coords[0,4])
plt.xlim(0,10)
plt.grid()
plt.show()
#+end_src

#+RESULTS:
:results:
# Out[513]:
[[file:./obipy-resources/LGVSc6.svg]]
:end:

#+begin_src ipython :session asession :results raw drawer :exports both
from matplotlib import animation

N = len(time)
dt = time[1] - time[0]

fig, (ax1, ax2, ax3, ax4, ax5) = plt.subplots(5,1, figsize=(8,12))
oscillators = np.zeros((5,5), dtype=object)
# lines = np.zeros((5,5), dtype=object)
for i, axis in enumerate([ax1, ax2, ax3, ax4, ax5]):
    for j in range(5):
        oscillators[i,j], = axis.plot([], [], lw=0, ms=20, marker='s', mfc='gray', fillstyle='full', mec='black', markevery=2)
        # lines[i,j], = axis.plot([], [], lw=1, color='r')

    axis.set_xlim(-10, 50)
    axis.set_xlabel('x')
    axis.set_ylabel('y')

def init_animation():
    ''' Initialise the animation as an empty object '''
    for i in range(5):
        for j in range(5):
            oscillators[i,j].set_data([], [])
            # lines[i,j].set_data([], [])
            yield oscillators[i,j]
    # return [oscillators[i,j] for i in range(5) for j in range(5)], [lines[i,j] for i in range(5) for j in range(5)]

def animate(k):
    distance = 10
    for i in range(5):
        for j in range(5):
            oscillators[i,j].set_data([distance*j + x_coords[i,j,k],0], [0,0])
            # lines[i,j].set_data(time[:k], x_coords[i,j][:k])
            yield oscillators[i,j]
    # return [oscillators[i,j] for i in range(5) for j in range(5)], [lines[i,j] for i in range(5) for j in range(5)]

ani = animation.FuncAnimation(fig, animate, np.arange(1, N),
                              interval=50, blit=True, init_func=init_animation,repeat=False)
plt.close()

ani.save('./media/pendulums.mp4', fps=20)
#+end_src

#+RESULTS:
:results:
# Out[514]:
:end:
[[file:./media/pendulums.gif]]
