#+TITLE: Assignment01

In order to run this code, the following packages will be necessesary:
#+begin_src ipython :session asession :exports code :results raw drawer
import numpy as np
import matplotlib.pylab as plt
#+end_src

#+RESULTS:
:results:
# Out[1]:
:end:

* Plotting an electrostatic field

The electrostatic field due to a point source charge $q$ is given by Coulomb's law,
#+begin_src ipython :session asession :exports code :results raw drawer
sources = {1: (-1,0), 1.1: (1,0), -1: (0,1), -1.1: (0,-1)}

def electrostatic_field(_x, _y) :
    l = list(sources.items())
    charges, source_x_positions_list, source_y_positions_list = [0]*len(l), [0]*len(l), [0]*len(l)

    i = 0
    while i < len(l) :
        charges[i], (source_x_positions_list[i], source_y_positions_list[i]) = l[i]
        i += 1

    n, m = np.shape(_y) # n and m are the same number, for _y is a square matrix, as is _x
    E_x, E_y = np.zeros((n,n)), np.zeros((n,n))

    i = 0
    while i < len(source_x_positions_list) :
        delta_pos_x = _x - source_x_positions_list[i]
        delta_pos_y = _y - source_y_positions_list[i]
        R = np.sqrt(delta_pos_x**2 + delta_pos_y**2)

        E_x += charges[i]*delta_pos_x/R**3
        E_y += charges[i]*delta_pos_y/R**3
        i += 1

    return E_x, E_y
#+end_src

#+RESULTS:
:results:
# Out[32]:
:end:

Position in y, as is defined, must be the converse (transpose) of position in x.
#+begin_src ipython :session asession :exports code :results raw drawer
%config InlineBackend.figure_format = 'svg'

def graph(boxlength, num_partitions) : # boxlength represents half the length of the side
    x = [[i*2*boxlength/(num_partitions-1) - boxlength for i in range(num_partitions)] for k in range(num_partitions)]
    y = x[:]
    x, y = np.array(x), np.array(y).T
    E_x, E_y = electrostatic_field(x, y)

    plt.gca().set_aspect('equal', adjustable='box')
    plt.streamplot(x, y, E_x, E_y, color='k', arrowstyle ='->')
    plt.xlabel('$x$')
    plt.ylabel('$y$')
    plt.show()

# execute the code
graph(2,20)
#+end_src

#+RESULTS:
:results:
# Out[36]:
[[file:./obipy-resources/2TqBW4.svg]]
:end:

* Projectile motion
#+begin_src ipython :session asession :exports code :results raw drawer
%config InlineBackend.figure_format = 'svg'
g = 9.8

def get_horiz_position(y_0, v_0, angle, y_ref) :
    t = (v_0*np.sin(angle) + np.sqrt((v_0*np.sin(angle))**2 - 2*g*(y_ref - y_0))) / g
    _x = v_0*np.cos(angle)*t
    return _x

def get_vert_position(y_0, v_0, angle, x_ref) :
    t = x_ref / (v_0*np.cos(angle))
    _y = y_0 + v_0*np.sin(angle)*t - 0.5*g*t**2
    return _y

def score_check(y_0, v_0, angle, x_basket, y_basket, radius) :
    _x = get_horiz_position(y_0, v_0, angle, y_basket)
    return bool(np.abs(_x - x_basket) < radius)

def plot(y_0, v_0, angle, x_basket, y_basket, radius) :
    _x = np.linspace(0, get_horiz_position(y_0, v_0, angle, 0), 40)
    _y = get_vert_position(y_0, v_0, angle, _x)

    if score_check(y_0, v_0, angle, x_basket, y_basket, radius) == True :
        plt.suptitle('Â¡Es una cesta!')
    else :
        plt.suptitle('No es una cesta.')

    plt.gca().set_aspect('equal', adjustable='box')
    plt.xlabel('$x$')
    plt.ylabel('$y$')
    plt.title('Trayectoria')
    plt.grid(True)
    plt.plot(_x,_y)
    plt.plot((x_basket - radius, x_basket + radius),(y_basket, y_basket))
    plt.show()

plot(y_0 = 2,
     v_0 = 8,
     angle = np.pi/3,
     x_basket = 5,
     y_basket = 3,
     radius = 0.23)
#+end_src

#+RESULTS:
:results:
# Out[37]:
[[file:./obipy-resources/filaKI.svg]]
:end:
